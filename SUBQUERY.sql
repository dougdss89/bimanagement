/*

================= SUB-QUERY =================

*/

-- DIVIDIDAS EM INNER E OUTER QUERY
-- INNER = QUERY INTERNA, RESULTADO É A BASE PARA A QUERY EXTERNA
-- OUTER = QUERY EXTERNA, RESULTADO FINAL

-- PODEM RESULTAR EM SINGLE-VALUE, MULTIVALUE E TABLE-VALUE
-- CLASSIFICADAS EM SELF-CONTAINED OU CORRELATED
-- SELF- CONTAINED NÃO POSSUI DEPENDÊNCIA DAS TABELAS EXTERNAS DA SUBQUERY, JÁ A CORRELATED POSSUI.

-- SELF-CONTAINED SCALAR SUBQUERY
-- SUBQUERY PARA RETORNAR O VALOR MÁXIMO DE UM PEDIDO E ARMAZENAR NUMA VARIÁVEL
-- O VALOR ARMAZENADO NA VARIÁVEL SERÁ RETORNADO NA QUERY EXTERNA
DECLARE @MAXID AS INT = (SELECT MAX(ORDERID)-- SUBQUERY SUBSTITUINDO O WHERE
						 FROM SALES.Orders);
SELECT ORDERID, ORDERDATE, EMPID, CUSTID
FROM SALES.Orders
WHERE orderid = @MAXID

-- SUBSTITUINDO A VARIAVÁVEL PELA SUBQUERY DE PADRÃO SELF-CONTAINED
SELECT orderid ORDERDATE, EMPID, CUSTID
FROM SALES.Orders 
WHERE orderid = (SELECT MAX(SO.ORDERID)
				 FROM SALES.Orders AS SO)

-- SE UMA SUBQUERY SCALAR RETORNAR MULTIPLOS VALORES, ELA ACUSARÁ ERRO
-- ESSA QUERY NÃO RETORNOU ERRO POIS SÓ HÁ UM EMPREGADO QUE ATENDE A CLÁUSULA WHERE NA SUBQUERY
SELECT ORDERID
FROM SALES.Orders
WHERE EMPID = (SELECT E.EMPID
			   FROM HR.Employees AS E
			   WHERE E.lastname LIKE 'c%')

-- O CONTRÁRIO NÃO ACONTECE COM ESSA QUERY
-- COMO ELA POSSUI MÚLTIPLOS VÁLORES, A QUERY RETORNA ERRO
SELECT ORDERID
FROM SALES.Orders
WHERE EMPID = (SELECT E.EMPID
			   FROM HR.Employees AS E
			   WHERE E.lastname LIKE 'D%')


-- AS SUBQUERIES QUANDO UMA CONSULTA RETORNA NULL, ELAS TRATAM COMO UNKNOWN E RETORNAM VAZIO
-- PARA RETORNAR NULL, DEVERIA DESTACAR COM O IS NULL
SELECT ORDERID 
FROM SALES.Orders
WHERE EMPID = (SELECT E.EMPID
			   FROM HR.Employees AS E
			   WHERE E.lastname LIKE 'A%');


-- SELF-CONTAINED QUE RETORNAM MÚLTIPLOS VALORES
-- ESSE TIPO DE QUERY ACEITA OPERADORES IN NA CLÁUSULA WHERE
-- SE A SUBQUERY RETORNAR 'TRUE' PARA O OPERADOR IN, A QUERY EXTERNA RETORNA MULTIPLOS VALORES
SELECT ORDERID
FROM SALES.Orders
WHERE empid IN -- AQUI, SUBSTIUI O ' = ' PELO IN
			 (SELECT empid
			  FROM HR.Employees AS E
			  WHERE E.lastname LIKE 'D%')

-- EXECUTANDO UMA SUBQUERY QUE 'NEGUE A EXISTÊNCIA' DE UM DETERMINADO VALOR
-- A QUERY INTERNA FAZ UMA COMPARAÇÃO COM A  EXTERNA E ASSIM, RETORNA O RESULTADO
SELECT CUSTID, COMPANYNAME 
FROM SALES.Customers AS C
WHERE COUNTRY = 'SPAIN'
AND NOT EXISTS 
		(SELECT * FROM SALES.ORDERS AS O
		 WHERE O.CUSTID = C.CUSTID)


SELECT CUSTID, ORDERID, ORDERDATE, EMPID
FROM SALES.ORDERS
WHERE CUSTID IN 
			   ( SELECT C.CUSTID
			     FROM SALES.Customers AS C
				 WHERE C.country = N'USA')

-- A QUERY ABAIXO RETORNA TODOS OS QUE NÃO FIZERAM PEDIDO
-- SENDO O FILTRO REALIZADO PELA QUERY INTERNA
SELECT CUSTID, COMPANYNAME
FROM SALES.Customers
WHERE custid NOT IN
	  (SELECT O.CUSTID
	   FROM SALES.ORDERS AS O)

-- RETORNANDO O VALOR MINIMO E MAXIMO COM UMA SUBQUERY
-- AQUI FOI NECESSÁRIO A CRIAÇÃO DE UMA TABELA ADICIONAL PARA AJUDAR A SOLUCIONAR

SELECT N 
FROM DBO.Nums
WHERE N BETWEEN (SELECT MIN(O.ORDERID) FROM SALES.ORDERS AS O)
		AND     (SELECT MAX(O.ORDERID) FROM SALES.ORDERS AS O)
		AND N NOT IN (SELECT O.ORDERID FROM SALES.ORDERS AS O);

-- SUBQUERY CORRELATAS
-- SÃO SUBQUERYS QUE DEPENDEM DE ATRIBUTOS QUE ESTÃO EM OUTRA QUERY
-- AS SUBQUERY PASSAM A DEPENDER DE UM ATRIBUTO EXTERNO E COM ISSO. NÃO PODEM SER EXECUTADAS SEM ELE

-- EXEMPLO
-- A QUERY INTERNA (SUBQUERY) PRECISA DO ATRIBUTO CUSTID PARA RETORNAR OS VALORES PARA ORDERID
-- E COMO PODEMOS VER, O CUSTID É UM ATRIBUTO 'EXCLUSIVO' DA QUERY EXTERNA, TORNANDO A SUBQUERY CORRELASTA OU DEPENDENTE
SELECT CUSTID, ORDERDATE, ORDERID, EMPID
FROM SALES.Orders AS O1
WHERE ORDERID = (
				 SELECT MAX(O2.ORDERID)
				 FROM SALES.ORDERS AS O2
				 WHERE O2.CUSTID = O1.CUSTID)
				 
-- CALCULANDO A PORCENTAGEM DE PEDIDO COM SUBQUERY CORRELATA
SELECT ORDERID, CUSTID, VAL, 
CAST(100 * VAL/ (SELECT SUM (O2.VAL)
				 FROM SALES.OrderValues AS O2
				 WHERE O2.custid = O1.CUSTID)
				 AS NUMERIC(5,2)) AS PCT
FROM SALES.ORDERVALUES AS O1
ORDER BY CUSTID, ORDERID;

-- EXISTS EM SUBQUERY
-- É ACEITO COMO ENTRADA PARA A SUBQUERY, QUE IRÁ RETORNAR TRUE SE HOUVER E FALSE, CASO NÃO
SELECT CUSTID, COMPANYNAME
FROM SALES.CUSTOMERS  AS C
WHERE COUNTRY = N'SPAIN'
AND EXISTS (SELECT * FROM SALES.ORDERS AS O
			WHERE O.custid = C.custid);

-- USANDO O NOT EXISTS
-- NEGANDO A EXISTENCIA DE UM GRUPO NA QUERY INTERNA PARA QUERY EXTERNA
-- USANDO O EXISTS (SELECT *) SE MOSTRA MAIS FÁCIL DE LER A QUERY
-- EMBORA O SELECT * NÃO SEJA ACONSELHÁVEL, COM O EXISTS ELE OTIMIZA O USO DESSA CONDIÇÃO, MELHORANDO A PERFORMANCE DA QUERY
SELECT CUSTID, COMPANYNAME
FROM SALES.Customers AS C
WHERE COUNTRY = N'SPAIN'
AND NOT EXISTS (SELECT * FROM SALES.Orders AS O
				WHERE O.CUSTID = C.CUSTID)

-- ALÉM DO FUNDAMENTO
-- RETORNANDO VALORES ANTERIORES OU PROXIMOS (DEPOIS)
-- VEJA ABAIXO, UMA QUERY QUE RETORNA O PEDIDO ANTERIOR PARA UM DETERMINADO PEDIDO
SELECT ORDERID, ORDERDATE, EMPID, CUSTID,
	(SELECT MIN (O2.ORDERID)
	FROM Sales.ORDERS AS O2
	WHERE O2.orderid > O1.ORDERID) AS PREVORDERID
FROM SALES.ORDERS AS O1 

-- USANDO VALORES DE AGREGAÇÃO  DE ACORDO COM UM PARÂMETRO 
-- SUPONHAMOS QUE PRECISAMOS COMPUTAR QUANTIDADE TOTAL POR ANO
-- DEPOIS SOMAR O ANO ATUAL + ANO ANTERIOR
-- QUERO PEGAR O TOTAL DE 2014, PEGAR 2015 E SOMAR COM 2014, PEGAR 2016 SOMAR COM 2015
SELECT ORDERYEAR, QTY
FROM SALES.ORDERTOTALSBYYEAR;


-- RESOLUÇÃO
-- A CONSULTA INTERNA SELECIONA A QUANTIDADE E SOMA ESSA QUANTIDADE DA VIEW CHAMADA OrderTotalsByYear 
-- COMPARA COM O PEDIDO POR ANO DA MESMA VIEW DA CONSULTA EXTERNA
-- A CONSULTA EXTERNA RETORNA O ANO E A QUANTIDADE SEM REALIZAR SOMA
SELECT ORDERYEAR, QTY,
	(SELECT SUM(O2.QTY)
	FROM SALES.OrderTotalsByYear  AS O2-- SELECIONANDO UMA VIEW QUE JÁ EXISTE COM A QUANTIDADE TOTAL
	WHERE O2.orderyear <= O1.ORDERYEAR) AS RUNQTY
FROM SALES.OrderTotalsByYear AS O1
ORDER BY orderyear

-- TRATANDO BUGS E ERROS DE SUBQUERY E ALGUMAS DICAS PARA SOLUÇÃO
INSERT INTO Sales.Orders
(custid, empid, orderdate, requireddate, shippeddate, shipperid,
freight, shipname, shipaddress, shipcity, shipregion,
shippostalcode, shipcountry)
VALUES(NULL, 1, '20160212', '20160212',
'20160212', 1, 123.00, N'abc', N'abc', N'abc',
N'abc', N'abc', N'abc');

SELECT CUSTID, COMPANYNAME
FROM SALES.Customers
WHERE custid IS NULL NOT IN (SELECT O.CUSTID
					FROM SALES.Orders AS O);

-- IN DEVERIA RETORNAR O 22 MAS QUANDO COMPARADO RETORNA FALSO OU DESCONHECIDO
-- PARA QUE A SUBQUERY RETORNE CORRETAMENTE UM VALOR NULL, A QUERY INTERNA PRECISA DA DECLARAÇÃO EXPLICITA QUE O NULL DEVE SER RETORNADO
-- SE ISSO NÃO OCORRER, A QUERY RETORNA APENAS UM CONJUNTO VAZIO
SELECT CUSTID, COMPANYNAME
FROM SALES.Customers
WHERE CUSTID NOT IN (SELECT O.CUSTID
					FROM SALES.Orders AS O
					WHERE O.custid  IS NOT NULL);

-- SUBSTITUINDO O NOT NULL POR NOT EXISTS
SELECT CUSTID, COMPANYNAME
FROM SALES.CUSTOMERS AS C
WHERE  NOT EXISTS (SELECT * FROM SALES.ORDERS AS O
						WHERE O.custid = C.CUSTID)

-- SUBSTITUINDO ERROS EM COLUNAS NAS SUBQUERYS
DROP TABLE IF EXISTS Sales.MyShippers;
CREATE TABLE Sales.MyShippers
(
shipper_id INT NOT NULL,
companyname NVARCHAR(40) NOT NULL,
phone NVARCHAR(24) NOT NULL,
CONSTRAINT PK_MyShippers PRIMARY KEY(shipper_id)
);
INSERT INTO Sales.MyShippers(shipper_id, companyname, phone)
VALUES(1, N'Shipper GVSUA', N'(503) 555-0137'),
(2, N'Shipper ETYNR', N'(425) 555-0136'),
(3, N'Shipper ZHISN', N'(415) 555-0138');

-- O 'ERRO' NA QUERY É RETORNAR UM VALOR DA COLUNA EXTERNA PARA A COLUNA INTERNA
-- A COLUNA SHIPPER_ID NÃO EXISTE NA TABELA ORDERS, PORÉM EXISTE NA TABELA MYSHIPPERS E POR ISSO, RETORNA 3 VALORES E NÃO 2
-- ESSE É UM COMPORTAMENTO DO PADRÃO SQL E NÃO DO SQL SERVER PARA EVITAR ATRIBUIÇÃO DE PREFIXO, UMA VEZ QUE NÃO SÃO AMBIGUOS
SELECT SHIPPER_ID, COMPANYNAME
FROM SALES.MyShippers
WHERE shipper_id IN (SELECT shipper_id
					FROM SALES.Orders
					WHERE custid = 43)

-- MELHORES PRÁTICAS PARA EVITAR O 'ERRO'
SELECT SHIPPER_ID, COMPANYNAME
FROM SALES.MYSHIPPERS
WHERE SHIPPER_ID IN (
					SELECT O.SHIPPERID --  ATRIBUINDO NOME PARA A COLUNA DA QUERY INTERNA COM NOME DIFERENTE
					FROM SALES.ORDERS AS O
					WHERE O.CUSTID = 43);




