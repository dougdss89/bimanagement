/*

					====== TABLE EXPRESSION ======

-- SÃO TABELAS QUE ESTÃO RELACIONADAS COM OUTRAS TABELAS
-- DERIVED TABLE, CTE, VIEW E TABLE-VALUED FUNCTION (TIPOS DE TABLE EXPRESSION)
-- NÃO SÃO TABELAS FÍSICAS, LOGO NÃO SÃO MATERIALIZADAS EM DISCO. SÃO TABELAS VIRTUAIS
-- SÃO DIVIDIDAS EM QUERY INTERNA E EXTERNA E JUNTAS, FORMAM O RESULTADO FINAL PARA A TABLE EXPRESSION
-- OS BENEFÍCIOS DE UMA QUERY EXTERNA ESTÃO MAIS VOLTADOS CÓDIGO EM SI DO QUE PERFORMANCE
-- TAMBÉM PERMITE QUE UMA TABELA COM ALIAS QUE NÃO PODERIA SER PROCESSADA ANTES DA CLÁUSULA SELECT, ASSIM O SEJA TRANSPASSANDO
   A RESTRIÇÃO
-- O IMPACTO DE UMA TABLE EXPRESSION COSTUMA SER NULO NO QUE TANGE A PERFORMANCE


   -- REGRAS
-- ORDER DE EXIBIÇÃO NÃO É GARANTIDA - ASSIM SENDO, NÃO É POSSÍVEL TER A CLÁUSULA ORDER BY NA QUERY INTERNA
-- TODAS AS COLUNAS DA TABELA QUE SERVE COMO DEFINIÇÃO PARA A QUERY EXTERNA DEVEM RECEBER NOME OU UM ALIAS
-- OS NOMES DEVEM SER ÚNICOS, NÃO SENDO POSSÍVEL REFERENCIAR O MESMO NOME DA COLUNA, SALVO SE DER UM NOVO APELIDO

COMO AS TABELAS DERIVADAS SÃO CONSIDERADAS RELAÇÕES, ELAS PRECISAM SEGUIR AS REGRAS QUE RESUMINDO:
-- TODOS OS ATRIBUTOS DA RELAÇÃO DEVEM TER NOME, TODO NOME DEVE SER ÚNICO E NÃO HÁ UMA ORDENAÇÃO CORRETA

*/

--						DERIVED TABLES
-- DERIVAÇÃO DE UMA TABELA LOGO APÓS A CLÁUSULA FROM DA QUERY EXTERNA
-- AO FINAL DA EXECUÇÃO DA QUERY, A QUERY EXTERNA DESAPACERE

-- EXEMPLOS DE TABELA DERIVADA (BANCO TSQLV4)
-- A QUERY INTERNA SELECIONA TODOS OS CLIENTES E NOMES DE EMPRESAS DA TABELA CLIENTES
-- FILTRANDO PELO PAÍS = EUA.
-- A QUERY EXTERNA PEGA TODAS AS LINHAS DAS TABELAS DAS QUERY INTERNA, RETORNANDO A CONSULTA.
-- NO FINAL, NOMEIA A QUERY INTERNA COMO USACUST
SELECT * FROM
(SELECT custid, companyname
	FROM SALES.CUSTOMERS
	WHERE COUNTRY = N'USA') AS USACUST

--					ATRIBUINDO ALIAS A TABELAS DERIVADAS
-- É POSSÍVEL ATRIBUIR UM ALIAS APLICADO NA QUERY INTERNA NA QUERY EXTERNA PARA CONSULTA
-- COM ESSE RECURSO, É POSSÍVEL INCLUSIVE, USAR O ALIAS NAS CLÁUSULAS WHERE E GROUP BY, ONDE POR NATUREZA NÃO É POSSÍVEL
-- REPARE A PRIMEIRA QUERY
SELECT YEAR(ORDERDATE) AS ORDERYEAR, COUNT(DISTINCT CUSTID) AS NUMCUST
FROM SALES.ORDERS
GROUP BY YEAR(ORDERDATE)

-- ESTA QUERY RETORNA ERRO POIS O GROUP BY É PROCESSADO PELA QUERY ANTES DO SELECT, ASSIM SENDO, ELE NÃO RECONHECE O ALIAS ATRIBUIDO
-- CORRIGINDO A SITUAÇÃO DA QUERY
-- ESSA CORREÇÃO OCORRE PQ A QUERY EXTERNA VAI BUSCAR OS RESULTADOS NA QUERY INTERNA E COMO ESTÁ COM O ALIAS NA COLUNA, É POSSÍVEL USAR
-- SE A COLUNA RECEBER UM ALIAS, O NOME ORIGINAL NÃO PODE SER USADO NA COLUNA EXTERNA
SELECT ORDERYEAR , COUNT(DISTINCT CUSTID) AS NUMCUST
FROM (SELECT YEAR(ORDERDATE) AS ORDERYEAR,
				 CUSTID
FROM SALES.ORDERS) AS D
GROUP BY ORDERYEAR;

-- ESTE É UM JEITO DE ATRIBUIR ALIAS PARA TODA A CONSULTA DA TABELA DERIVADA ATRIBUINDO AO FINAL DA QUERY INTERNA
-- ACHEI MUITO CONFUSO
SELECT ORDERYEAR, COUNT(DISTINCT CUSTID) AS NUMCUST
FROM (SELECT YEAR(ORDERDATE) AS ORDERYEAR, CUSTID
		FROM SALES.ORDERS) AS D (ORDERYEAR, CUSTID)
GROUP BY ORDERYEAR;


--			USANDO ARGUMENTOS
-- PODE SER USADO PARA VALORES DE INPUT EM PARÂMETROS DE STORED PROCEDURE E FUNÇÃO
-- PODE SER UMA VARIÁVEL LOCAL OU GLOBAL
-- VEMOS O EXEMPLO A SEGUIR
DECLARE @EMPID AS INT = 3
SELECT ORDERYEAR, COUNT(DISTINCT custid) AS NUMCOUNT
FROM (SELECT YEAR(ORDERDATE) AS ORDERYEAR, CUSTID
		FROM SALES.ORDERS
		WHERE empid = @EMPID +1) AS D
GROUP BY ORDERYEAR;

-- A QUERY DECLARA UMA VARIÁVEL COMO INTEIRO E ATRIBUI O VALOR DE 3
-- NA QUERY INTERNA A CLÁUSULA WHERE FAZ UMA BUSCA SE BASEANDO NA VARIÁVEL DECLARADA E IRÁ RETORNAR OS VALORES ATRIBUIDOS A ELA
-- A QUERY INTERNA INFORMA OS VALORES PRA A QUERY EXTERNA ENCERRANDO A CONSULTA

--			CRIANDO ANINHAMENTO EM DERIVED TABLE
-- PERMITE CRIAR UMA TABELA DERIVADA ORIGINADA DE OUTRA TABELA DERIVADA
-- TENDE A TORNAR O CÓDIGO MAIS SUJO E POUCO LEGÍVEL
SELECT ORDERYEAR, NUMCUST
FROM (SELECT ORDERYEAR, COUNT(DISTINCT custid) AS NUMCUST
		FROM (SELECT YEAR(ORDERDATE) AS ORDERYEAR, CUSTID 
				FROM SALES.ORDERS) AS D1
		GROUP BY ORDERYEAR) AS D2 
WHERE NUMCUST > 72;

SELECT PRODUCT, SUM(TOTALPROD)
FROM (SELECT productid AS PRODUCT, (QTY) AS TOTALPROD
		FROM SALES.OrderDetails) AS D1
GROUP BY PRODUCT, TOTALPROD

--			 MULTIPLAS REFERÊNCIAS
-- QUANDO QUEREMOS RELACIONAR MULTIPLAS CONSULTAS DE TABELAS DERIVADAS POR UM COMANDO DE JOIN
-- UMA VEZ ATRIBUIDO UM ALIAS PARA UM INPUT DO JOIN, NÃO PODEMOS ATRIBUIR O MESMO PARA OUTRO INPUT
SELECT CUR.ORDERYEAR, CUR.NUMCUSTS AS CURNUMCUSTS, PRV.NUMCUSTS AS PRVNUMCUSTS,
	   CUR.NUMCUSTS - PRV.NUMCUSTS AS GROWTH
FROM (SELECT YEAR(ORDERDATE) AS ORDERYEAR, COUNT(DISTINCT(CUSTID)) AS NUMCUSTS
		FROM SALES.Orders 
		GROUP BY YEAR(orderdate)) AS CUR -- QUERY A ESQUERDA DO JOIN
LEFT JOIN 
	 (SELECT YEAR(ORDERDATE) AS ORDERYEAR, COUNT(DISTINCT(CUSTID)) AS NUMCUSTS
		FROM SALES.Orders
		GROUP BY YEAR(orderdate)) AS PRV -- QUERY A DIREITA DO JOIN
ON CUR.ORDERYEAR = PRV.ORDERYEAR + 1;

--			C.T.E - COMMON TABLE EXPRESSION
-- UMA VARIAÇÃO DAS TABELAS DERIVADAS
-- SÃO DEFINIDAS COMEÇANDO PELA DECLARAÇÃO WITH
-- A QUERY INTERNA DEFINE O QUE A CTE DEVE SEGUIR E A EXTERNA SELECIONA A CTE
-- O ; DEVE SER APLICADO AO FINAL DA QUERY QUE SELECIONA A CTE, SE FOR ANTES, IRÁ ACUSAR ERRO
WITH USACUSTS AS
(
SELECT CUSTID, COMPANYNAME
FROM SALES.Customers
WHERE COUNTRY = N'USA'
)
SELECT * FROM USACUSTS;

-- APLICANDO ALIAS NAS CTE's
-- PODEM SER DE MANEIRA INLINE E EXTERNA
-- ABAIXO UMA QUERY COM O ALIAS INLINE
-- A ESCOLHA FICA A CRITÉRIO DO USUÁRIO
WITH C AS 
(
SELECT YEAR(ORDERDATE) AS ORDERYEAR, CUSTID
FROM SALES.Orders
)
SELECT ORDERYEAR, COUNT(DISTINCT (CUSTID)) AS NUMCUSTS
FROM C
GROUP BY ORDERYEAR;

-- APLICANDO ALIAS EXTERNO EM UMA CTE
WITH C (ORDERYEAR, CUSTID) AS 
(
SELECT YEAR (ORDERDATE) AS ORDERYEAR, CUSTID
FROM SALES.Orders
)
SELECT ORDERYEAR, COUNT(DISTINCT(CUSTID)) AS NUMCUSTS
FROM C
GROUP BY ORDERYEAR;

-- ARGUMENTOS EM C.T.E
-- UTILIZANDO VARIÁVREIS NA CONSTRUÇÃO DE CTE
DECLARE @EMPID AS INT = 3;
WITH C AS
(
SELECT YEAR(ORDERDATE) AS ORDERYEAR, CUSTID
FROM SALES.Orders
WHERE EMPID = @EMPID
)
SELECT ORDERYEAR, COUNT(DISTINCT(CUSTID)) AS NUMCUSTS
FROM C
GROUP BY ORDERYEAR

-- CRIANDO MULTIPLAS CTE's
-- CRIA DIVERSAS CTE'S NO MESMO BATCH DE COMANDO
-- TEM A VANTAGEM DE NÃO PRECISAR ANINHAR COMO OCORRE EM DERIVED TABLES
-- TAMBÉM TORNA A LEITURA DO COMANDO MAIS LIMPA COM FACILIDADE DE IDENTIFICAÇÃO
WITH C1 AS 
(
SELECT YEAR(ORDERDATE) AS ORDERYEAR, CUSTID 
FROM SALES.Orders
),
	C2 AS
(SELECT ORDERYEAR, COUNT(DISTINCT(CUSTID)) NUMCUSTS
FROM C1
GROUP BY ORDERYEAR
)
SELECT ORDERYEAR, NUMCUSTS
FROM C2
WHERE NUMCUSTS > 70;

-- UTILIZANDO JOIN EM CTE
-- UMA ÚNICA QUERY SERVIU PRA QUE A CTE DESSE BASE PARA SERVIR DE REFERÊNCIA EM MAIS DE UMA
-- O CUSTO DE PERFORMANCE CONTINUA BAIXO ASSIM COMO DAS DERIVED TABLE
WITH YearlyCount AS
(
SELECT YEAR(orderdate) AS orderyear, -- QUERY INTERNA
COUNT(DISTINCT custid) AS numcusts
FROM Sales.Orders
GROUP BY YEAR(orderdate)
)
SELECT Cur.orderyear,
Cur.numcusts AS curnumcusts, Prv.numcusts AS prvnumcusts,
Cur.numcusts - Prv.numcusts AS growth
FROM YearlyCount AS Cur
LEFT OUTER JOIN YearlyCount AS Prv
ON Cur.orderyear = Prv.orderyear + 1;

-- RECURSÃO DE CTE
-- FUNCIONA COM NO MÍNIMO, DUAS QUERIES
-- É DIVIDIDA EM DUAS ESTRUTURAS QUERY ANCORA E QUERY RECURSIVA
-- O MEMBRO ANCORA RETORNA O VALOR VÁLIDO E É INVOCADO APENAS UMA VEZ
-- O MEMBRO RECURSIVO CHAMA PELO NOME DA CTE E REPETE A OPERAÇÃO ATÉ QUE RETORNE UM VALOR VAZIO
WITH EMPSCTE AS
(
SELECT EMPID, MGRID, FIRSTNAME, LASTNAME
FROM HR.Employees
WHERE empid = 2

UNION ALL

SELECT C.EMPID, C.MGRID, C.FIRSTNAME, C.LASTNAME
FROM EMPSCTE AS P
	INNER JOIN HR.Employees AS C
	ON C.mgrid = P.mgrid
)
SELECT EMPID, MGRID, FIRSTNAME, LASTNAME
FROM EMPSCTE

--				VIEWS
-- AS VIEWS PODEM SER CONSIDERADAS OBJETOS DENTRO DO BANCO DE DADOS
-- AO CONTRÁRIO DAS CTE E DAS DERIVED TABLE, ESTAS SÃO ARMAZENADAS EM DISCO
-- A VIEW É CRIADA A PARTIR DAS COLUNAS DE UMA TABELA UTILIZADA
-- PODER SER UTIL PARA FILTRAR AS COLUNAS DE UMA TABELA COM DADOS CONFIDÊNCIAIS
-- SE A TABELA QUE DEU ORIGEM A VIEW FOR ATUALIZADA, ISSO NÃO ATUALIZA A VIEW
-- QUALQUER ALTERAÇÃO NA VIEW DEVE SER FEITA ATRAVÉS DO COMANDO ALTER, UPDATE ETC

-- CRIANDO VIEW
DROP VIEW IF EXISTS SALES.USACUSTS
GO
CREATE VIEW SALES.USACUSTS
AS
SELECT CUSTID, COMPANYNAME, CONTACTNAME, CONTACTTITLE, [ADDRESS]
	   CITY, REGION, POSTALCODE, COUNTRY, PHONE, FAX
FROM SALES.Customers
WHERE country = N'USA';
GO

-- ALTERANDO UMA VIEW
-- PARA ALTERTAR A VIEW, É PRECISO REESCREVER COMO SE FOSSE RECRIAR UMA VIEW 
-- NÃO É POSSÍVEL APLICAR O ORDER BY EM VIEWS MAS, PODEMOS SELECIONAR A VIEW E EXIBIR O RESULTADO COM O ORDER BY
ALTER VIEW SALES.USACUSTS
AS
SELECT CUSTID, COMPANYNAME, CONTACTNAME, CONTACTTITLE, [ADDRESS]
	   CITY, REGION, POSTALCODE, COUNTRY, PHONE, FAX
FROM SALES.Customers
WHERE country = N'USA'

SELECT custid, companyname
FROM SALES.USACUSTS
ORDER BY custid;

-- NA VIEW ABAIXO, UTILIZAMOS O TOP (100) PERCENT PARA TENTAR ORDENAR A VIEW
-- REPARE QUE ISSO NÃO ACONTECEU COM A QUERY SELECINANDO A VIEW, UMA VEZ QUE O CAMPO REGIÃO NÃO ESTÁ ORDENADO
-- PARA QUE A ORDEM SEJA ASSEGURADA, A QUERY QUE CHAMA A VIEW DEVE TER A ORDER BY ESPECIFICADA NA CONSULTA
ALTER VIEW SALES.USACUSTS
AS
SELECT TOP (100) PERCENT 
	   CUSTID, COMPANYNAME, CONTACTNAME, CONTACTTITLE, [ADDRESS]
	   CITY, REGION, POSTALCODE, COUNTRY, PHONE, FAX
FROM SALES.Customers
WHERE country = N'USA' 
ORDER BY region;

SELECT CUSTID, COMPANYNAME, REGION
FROM SALES.USACUSTS	

--			 OPÇÕES SUPORTADAS PARA CRIAÇÃO DE VIEW
-- NA CRIAÇÃO DA VIEW, PODEMOS ESPECIFICAR ALGUNS ATRIBUTOS E OPÇÕES COMO PARTE DA SUA DEFINIÇÃO
-- UTILIZANDO O WITH, PODEMOS ESPECIFICAR SCHEMMABINDING, ENCRYPTION, CHECK

-- UTILIZANDO VIEW COM ENCRYPTION
-- TODO O TEXTO DA VIEW PASSA A SER CRIPTOGRAFADO
ALTER VIEW SALES.USACUSTS WITH ENCRYPTION
AS
SELECT 
	CUSTID, COMPANYNAME, CONTACTNAME,CONTACTTITLE,ADDRESS,
	CITY, REGION, POSTALCODE, COUNTRY, PHONE, FAX
FROM SALES.Customers
WHERE REGION = N'USA';
GO

--			OPTION DE SCHEMABINDING EM VIEWS
-- CRIA UM LAÇO ENTRE O OBJETO REFERENCIADO E O REFERENCIADOR
-- NÃO É POSSÍVEL DELETAR OU ALTERAR OS OBJETOS REFERENCIADOS JUNTO DA VIEW
-- O SCHEMABINDING IRÁ CRIAR LIGAÇÃO COM O SCHEMA DA CLÁUSULA FROM
-- IMPEDE ERRO DE CONSISTÊNCIA UMA VEZ QUE NÃO É POSSÍVEL DELETAR OU ALTERAR OBJETOS REFERENCIADOS
-- NÃO É PERMITIDO O USO DE SELECT *
-- TODAS AS COLUNAS DEVEM SER DEVIDAMENTE NOMEADAS
ALTER VIEW SALES.USACUSTS WITH SCHEMABINDING
AS
SELECT 
	CUSTID, COMPANYNAME, CONTACTNAME,CONTACTTITLE, [ADDRESS],
	CITY, REGION, POSTALCODE, COUNTRY, PHONE, FAX
FROM SALES.Customers
WHERE COUNTRY = N'USA';
GO

--			CHECK OPTION EM VIEWS
-- CRIAR UM OBJETO DE CHECAGEM QUE AVALIA SE UMA DETERMINADA MUDANÇA PODE SER REALIZADA
-- EVITAR CONFLITO COM OS FILTROS DE UMA VIEW
-- SEM UM CHECK É POSSÍVEL INSERIR OU ATUALIZAR UMA VIEW COM VALORES QUE ESTÃO FORA DO ESCOPO CAUSANDO PROBLEMA
-- SE UM DETERMINADO UPDT FOR FEITO MESMO IGNORANDO O FILTRO ELE É EXECUTADO, A DIFERENÇA É QUE A LINHA ATUALIZADA NÃO É MAIS EXIBIDA
-- O CHECK É BASEADO NA CLÁUSULA WHERE
ALTER VIEW SALES.USACUSTS WITH SCHEMABINDING
AS 
SELECT 
	CUSTID, COMPANYNAME, CONTACTNAME,CONTACTTITLE, [ADDRESS],
	CITY, REGION, POSTALCODE, COUNTRY, PHONE, FAX
FROM SALES.Customers
WHERE COUNTRY = N'USA'
WITH CHECK OPTION;

--							TABLE-VALUED FUNCTION
-- SÃO TABELAS DE EXPRESSÕES QUE ACEITAM PARÂMETROS DE INPUT
-- SÃO SIMILAR AS VIEWS
-- NÃO FUNCTION ABAIXO, CRIAMOS UMA FUNÇÃO QUE ACEITA COMO PARÂMETRO UM VALOR INTEIRO E QUANDO A FUNÇÃO É CHAMADA, RETORNA OS VALORES

DROP FUNCTION IF EXISTS DBO.GETCUSTORDERS;
GO
CREATE FUNCTION DBO.GETCUSTORDERS
(@CID AS INT) RETURNS TABLE
AS
	RETURN 
SELECT 
	orderid, custid, empid, orderdate, requireddate,
	shippeddate, shipperid, freight, shipname, shipaddress, shipcity,
	shipregion, shippostalcode, shipcountry
FROM Sales.Orders 
WHERE custid = @CID
GO

-- A QUERY EXECUTADA AQUI, RETORNA TODOS OS PEDIDOS FEITO PELO CLIENTE DE ID 1
SELECT ORDERID, CUSTID
FROM DBO.GETCUSTORDERS(1) AS O;

-- É POSSÍVEL JUNTAR UMA TVF COM JOIN
-- A CLÁUSULA FROM CHAMOU A TVF COMPARANDO O VALOR PASSADO NA FUNÇÃO COM O ID DO VALOR NA TABELA ORDERSDETAILS
SELECT O.ORDERID, O.CUSTID, OD.PRODUCTID, OD.QTY
FROM DBO.GETCUSTORDERS(1) AS O
	INNER JOIN SALES.OrderDetails AS OD
ON O.orderid = O.orderid


--					APPLY OPERATOR
-- É UM OPERADOR USADO NA CLÁUSULA FROM
-- DOIS TIPOS: CROSS E OUTER APLLY
-- CROSS IMPLEMENTA APENAS UMA ÚNICA FASE, OUTER IMPLEMENTA DUAS FASES LÓGICAS
-- OPERA EM DUAS TABELAS PASSADAS COMO VALORES DE ENTRADA
-- OUTER APLLY É SIMILAR AO LEFT JOIN 

-- EXEMPLO
SELECT S.SHIPPERID, E.EMPID
FROM SALES.Shippers AS S
CROSS JOIN HR.Employees AS E

SELECT S.SHIPPERID, E.EMPID
FROM SALES.Shippers AS S
CROSS APPLY HR.Employees AS E

SELECT C.CUSTID, A.ORDERID, A.ORDERDATE
FROM SALES.Customers AS C
	CROSS APPLY
		(SELECT TOP (3) ORDERID, EMPID, ORDERDATE, REQUIREDDATE
		FROM SALES.Orders AS O
		WHERE O.custid = C.custid
		ORDER BY orderdatE DESC, orderid DESC) AS A

-- CRIANDO UMA T.V.F UNIDA COM APPLY 
DROP FUNCTION IF EXISTS dbo.TopOrders;
GO
CREATE FUNCTION dbo.TopOrders
(@custid AS INT, @n AS INT)
RETURNS TABLE
AS
RETURN
SELECT TOP (@n) orderid, empid, orderdate, requireddate
FROM Sales.Orders
WHERE custid = @custid
ORDER BY orderdate DESC, orderid DESC;
GO

SELECT
C.custid, C.companyname,
A.orderid, A.empid, A.orderdate, A.requireddate
FROM Sales.Customers AS C
CROSS APPLY dbo.TopOrders(C.custid, 3) AS A
ORDER BY empid


